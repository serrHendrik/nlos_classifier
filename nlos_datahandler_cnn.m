classdef nlos_datahandler_cnn
    %NLOS_DATAHANDLER_CNN Summary of this class goes here
    %   This is a separate datahandler to use with Convolution Neural Networks
    %   (CNNs). The reason a separate datahandler was created, is that CNNs
    %   in this project are used to extract extra information out of a
    %   timeseries of every input variable (e.g. the last 5 seconds of the
    %   pseudorange etc.). This required different data tables, which are
    %   also present in the data folder (e.g.
    %   AMS_01_datatable_CNN_LAG4.csv).
    %   
    %   A lot of funcitonality was copied from the nlos_datahandler, which
    %   is obviously not good. It would be better if both datahandlers
    %   inherit from an abstract parent datahandler which provides shared
    %   functionality.

    
    properties(Access = private)
        dataset_name
        file_location
        filename_output
        GPS_flag
        GAL_flag
        GLO_flag
        lag
        normalize_flag
        data_base           %data table as generated by nlos_datahandler
        base_features
    end
    properties
       data
    end
    properties(Dependent)
       full_filename_output 
       label_name
       fraction_los
       fraction_nlos
    end
    
    methods
        function obj = nlos_datahandler_cnn(tour_name, GPS_flag, GAL_flag, GLO_flag, lag)
            obj.GPS_flag = GPS_flag;
            obj.GAL_flag = GAL_flag;
            obj.GLO_flag = GLO_flag;
            obj.lag = lag;
            
            %calls the apropriate tour init function after creating an object.
            switch tour_name
                case 'AMS_01'
                    obj = obj.init_AMS_01();
                case 'AMS_02'
                    obj = obj.init_AMS_02();
                case 'ROT_01'
                    obj = obj.init_ROT_01();
                case 'ROT_02'
                    obj = obj.init_ROT_02();
            end
            
            %Select appropriate constellations
            obj = obj.select_constellations();
            
        end
        
        function v = get.full_filename_output(obj)
            v = strcat(obj.file_location,obj.filename_output);
        end
        
        function v = get.label_name(obj)
            v = strcat('los_',num2str(obj.lag));
        end
        
        function v = get.fraction_los(obj)
           not_nan_data = obj.data{~isnan(obj.data{:,{obj.label_name}}),{obj.label_name}};
           v = sum(not_nan_data) / length(not_nan_data); 
        end
        
        function v = get.fraction_nlos(obj)
           v = 1 - obj.fraction_los;
        end
        
        function obj = select_constellations(obj)
            
            if ~obj.GPS_flag && ~obj.GAL_flag && ~obj.GLO_flag
                disp('No constellation selected.')
                return
            end
            
            mask_GPS = cell2mat(obj.data.sv_sys) == 'G';
            mask_GAL = cell2mat(obj.data.sv_sys) == 'E';
            mask_GLO = cell2mat(obj.data.sv_sys) == 'R';
            
            mask = obj.GPS_flag&mask_GPS | obj.GAL_flag&mask_GAL | obj.GLO_flag&mask_GLO;
            
            obj.data = obj.data(mask,:); 
            
            %User feedback:
            disp('Selected constellations:')
            if obj.GPS_flag
                fprintf('GPS ')
            end
            if obj.GAL_flag
                fprintf('GAL ')
            end
            if obj.GLO_flag
                fprintf('GLO ')
            end
            fprintf('\n\n')
        end
   
        function X_features = get_X_features(obj, base_features, lag)
            N = length(base_features);
            X_features = cell(1,N*lag);
            
            %Add all features with lag identifier
            for j = 1:length(base_features)
               for i = 1:lag
                   X_features{i + (j-1)*lag} = [base_features{j}, '_', num2str(i)];
               end
            end 
            
        end

        function [data_subset,data_rest] = sample_data_timewise(obj, data, mod_b, mod_rest)
            
            fprintf('Sampling data... ')
            
            mask_ss = mod(data.common_time_1,mod_b) == mod_rest;
            mask_inv = ~mask_ss;
            
            data_subset = data(mask_ss,:);
            data_rest = data(mask_inv,:);
            
            size_orig = length(mask_ss);
            size_samp = sum(mask_ss);
            frac_samp = size_samp / size_orig;
            fprintf('done!\n')
            fprintf('Original data size: %d (100%%), sample set size: %d (%.2f%%)\n',size_orig,size_samp,frac_samp*100);

        end
        
        function [data_subset,data_rest] = sample_data_balance_classes(obj, data)
            nb_los = sum(data.(obj.label_name));
            nb_nlos = height(data) - nb_los;

            %nlos indices
            subset_mask = data.(obj.label_name) == 0;
            %los indices
            los_ind = datasample(find(data.(obj.label_name)),nb_nlos,'Replace', false);
            
            %mask
            subset_mask(los_ind) = true;
            
            %subset
            data_subset = data(subset_mask,:);
            data_rest = data(~subset_mask,:);
            
        end
        
        
        function [data_subset,data_rest] = sample_data_classwise(obj, data, holdout_frac)
            c = cvpartition(height(data),'Holdout', holdout_frac);
            
            data_subset = data(c.training,:);
            data_rest = data(c.test,:);
            
            
        end
        
        function print_info_per_const(obj, datatable)
            mask_GPS = cell2mat(datatable.sv_sys) == 'G';
            mask_GAL = cell2mat(datatable.sv_sys) == 'E';
            mask_GLO = cell2mat(datatable.sv_sys) == 'R';
            
            datatable_GPS = datatable(mask_GPS,:);
            datatable_GAL = datatable(mask_GAL,:);
            datatable_GLO = datatable(mask_GLO,:);
            
            nb_obs_GPS = height(datatable_GPS);
            nb_obs_GAL = height(datatable_GAL);
            nb_obs_GLO = height(datatable_GLO);
            nb_obs_total = height(datatable);
            
            frac_los_GPS = NaN;
            frac_los_GAL = NaN;
            frac_los_GLO = NaN;
            frac_los_total = sum(datatable.(obj.label_name)) / length(datatable.(obj.label_name));
            if nb_obs_GPS ~= 0
                frac_los_GPS = sum(datatable_GPS.(obj.label_name)) / length(datatable_GPS.(obj.label_name));
            end
            if nb_obs_GAL ~= 0
                frac_los_GAL = sum(datatable_GAL.(obj.label_name)) / length(datatable_GAL.(obj.label_name));
            end
            if nb_obs_GLO ~= 0
                frac_los_GLO = sum(datatable_GLO.(obj.label_name)) / length(datatable_GLO.(obj.label_name));
            end

            
            
            fprintf('\n********** Info on datatable ****************\n');
            fprintf('             #observations    frac_los    frac_nlos\n');
            fprintf('GPS          %d                %.2f       %.2f\n',nb_obs_GPS, frac_los_GPS, 1-frac_los_GPS);
            fprintf('GAL          %d                %.2f       %.2f\n',nb_obs_GAL, frac_los_GAL, 1-frac_los_GAL);
            fprintf('GLO          %d                %.2f       %.2f\n',nb_obs_GLO, frac_los_GLO, 1-frac_los_GLO);
            fprintf('Total        %d                %.2f       %.2f\n', nb_obs_total, frac_los_total, 1-frac_los_total);
            fprintf('************************************************\n\n');
            
        end
        
    end
    
    methods(Access = private)
      
        function obj = init_AMS_01(obj)
           
            obj.dataset_name = 'AMS_01';
            obj.file_location = 'data/AMS_01/';
            obj.filename_output = ['AMS_01_datatable_CNN_LAG',num2str(obj.lag),'.csv'];
            
            obj = obj.init_datahandler_cnn();
            
        end
        
        function obj = init_AMS_02(obj)
           
            obj.dataset_name = 'AMS_02';
            obj.file_location = 'data/AMS_02/';
            obj.filename_output = ['AMS_02_datatable_CNN_LAG',num2str(obj.lag),'.csv'];
            
            obj = obj.init_datahandler_cnn();
            
        end
        
        function obj = init_ROT_01(obj)
           
            obj.dataset_name = 'ROT_01';
            obj.file_location = 'data/ROT_01/';
            obj.filename_output = ['ROT_01_datatable_CNN_LAG',num2str(obj.lag),'.csv'];
            
            obj = obj.init_datahandler_cnn();
            
        end

        function obj = init_ROT_02(obj)
           
            obj.dataset_name = 'ROT_02';
            obj.file_location = 'data/ROT_02/';
            obj.filename_output = strcat('ROT_02_datatable_CNN_LAG',num2str(obj.lag),'.csv');
            
            obj = obj.init_datahandler_cnn();
            
        end
        
        function obj = init_datahandler_cnn(obj)
           
            %Check if datatable already exists
            if isfile(obj.full_filename_output)
                disp('Output file already exists.')
                obj = obj.load_data_table();
            else
                disp('Constructing data table...')
                obj = obj.construct_table();
                obj.save_data_table();
            end
            
        end
        
        function obj = construct_table(obj)

            %create base datahandler for ALL constellations and NOT normalised!
            echo off;
            dh_base = nlos_datahandler(obj.dataset_name, true, true, true, false);
            echo on;
            obj.data_base = dh_base.data;
            
            %init feature table
            obj.base_features = {'common_time', 'pseudorange', 'carrierphase', 'cnr', 'doppler', 'az', 'el', 'innovations'};
            %base_features = {'pseudorange', 'cnr', 'doppler', 'el', 'innovations'};
            [sv_feature_table_template, X_features, Y_feature] = obj.init_cnn_feature_table();
            obj.data = sv_feature_table_template;
            
            
            for c = 'GER'
                ids = dh_base.constellation_info.(c).allSv;
                for i = 1:length(ids)
                    sv_id = ids(i);
                    %sv table
                    mask_part1 = (cell2mat(obj.data_base.sv_sys) == c);
                    mask_part2 = (obj.data_base.sv_id == sv_id);
                    sv_table_mask = mask_part1 & mask_part2;
                    
                    %extract new features
                    sv_feature_table = obj.extract_features_CNN_for_sv(c, sv_id, sv_table_mask, sv_feature_table_template);
                    
                    %expand feature table
                    obj.data = [obj.data; sv_feature_table];
                    
                    %User feedback
                    fprintf('Constructing lag table, approx. %.2f%% complete\n', height(obj.data)/height(obj.data_base)*100);
                    
                end
            end
            
            %filter datarows with non consecutive time
            ct_1 = 'common_time_1';
            ct_p = strcat('common_time_',num2str(obj.lag));
            
            time_window = obj.data{:,{ct_p}} - obj.data{:,{ct_1}};
            wrong_rows = time_window ~= (obj.lag-1);
            obj.data = obj.data(~wrong_rows,:);
            
            fprintf('Done.\n\n');
 
        end
        
        function [feature_table, X_features, Y_feature] = init_cnn_feature_table(obj)
            
            %Get X_features
            X_features = obj.get_X_features(obj.base_features, obj.lag);

            %Add sat_sys and sat_id and label
            Y_feature = {['los_', num2str(obj.lag)]};
            all_features = [{'sv_sys'}, {'sv_id'}, X_features, Y_feature];
            
            %init table
            table_width = length(all_features);
            feature_table = cell2table(cell(0,table_width),'VariableNames',all_features);
            
            
        end
        
        function sv_feature_table = extract_features_CNN_for_sv(obj, sv_sys, sv_id, sv_table_mask, sv_feature_table_template)
            
            %get sv_table
            sv_table = obj.data_base(sv_table_mask, :);
            
            sv_feature_table = sv_feature_table_template;
            N = height(sv_table);
            
            if (N >= obj.lag)
                
                for i = 1:N-obj.lag+1
                    
                    row_mat = sv_table{i:i+obj.lag-1, obj.base_features};
                    row_cell = num2cell(transpose(row_mat(:)));
                    label = sv_table{i+obj.lag-1,{'los'}};
                    row = [{sv_sys}, {sv_id}, row_cell, {label}];
                    
                    sv_feature_table = [sv_feature_table; row];
                    
                end
                
            end
            
            
        end
                
        function save_data_table(obj)
            
            fprintf('Writing data table... ')
            writetable(obj.data,obj.full_filename_output);
            fprintf('done!\n')
            
        end
        
        function obj = load_data_table(obj)
            
            fprintf('Loading data table... ')
            obj.data = readtable(obj.full_filename_output);
            fprintf('done!\n')   
            
        end
        
    end
end

